#!/usr/bin/perl

######################################################################
# script to poll pagerduty for new acks to alerts generated by pagerduty_nagios.pl
# https://github.com/PagerDuty/pagerduty-nagios-pl
#
# it's handy to ack nagios alerts from pagerduty's sms or phone
# interface the same way you might for an email alert.  this will get
# acks to nagios alerts fed back to nagios
#
# also a resolve in pagerduty will create an ack in nagios
######################################################################

######################################################################
#Permission is hereby granted, free of charge, to any person
#obtaining a copy of this software and associated documentation
#files (the "Software"), to deal in the Software without
#restriction, including without limitation the rights to use,
#copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the
#Software is furnished to do so, subject to the following
#conditions:
#
#The above copyright notice and this permission notice shall be
#included in all copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#OTHER DEALINGS IN THE SOFTWARE.
######################################################################

use Getopt::Long;
use JSON;
use Data::Dumper;
use strict;
use Storable;

my(%opts);
my(@opts)=('debug',
           'nagios_status_file|s=s',
           'nagios_command_pipe|c=s',
           'pagerduty_token|p=s',
           'pagerduty_subdomain|u=s',
           'last_id_file=s',
           'last_id=i',
           'help|h',
    );

die unless GetOptions(\%opts,@opts);

if($opts{help}){
  print <<EOT;
$0: pass pagerduty acknowledgements into nagios

options:

 --debug | -d
 --nagios_status_file <_file> | -s <_file> (default /var/cache/nagios/status.dat)
 --nagios_command_pipe <_file> | -c <_file> (default /var/spool/nagios/cmd/nagios.cmd)
 --pagerduty_token <_token> | -p <_token>
 --pagerduty_subdomain <_subdomain> | -u <_subdomain>
 --last_id_file <_file> | -l <_file> (default /tmp/pd_ack_to_nagios_ack_poller.last_id)
 --last_id <_id> (overrides and skips saving to last_id_file)
 --help | -h (this message)
EOT
exit 0;
} 

$opts{nagios_status_file} ||= '/var/cache/nagios/status.dat';
$opts{nagios_command_pipe} ||= '/var/spool/nagios/cmd/nagios.cmd';
$opts{last_id_file} ||= '/tmp/pd_ack_to_nagios_ack_poller.last_id';

die "can't access last_id_file $opts{last_id_file}"
   if(!defined($opts{last_id}) &&
      (-e $opts{last_id_file}) && !(-w $opts{last_id_file}));
die "can't access pipe $opts{nagios_command_pipe}" if(!(-w $opts{nagios_command_pipe}));
die "--pagerduty_token|-p required" unless($opts{pagerduty_token});
die "--pagerduty_subdomain|-u required" unless($opts{pagerduty_subdomain});

my($j, $cmd);
$cmd = "curl -s -H 'Authorization: Token token=$opts{pagerduty_token}' " .
    "'https://$opts{pagerduty_subdomain}.pagerduty.com/api/v1/incidents?fields=incident_number,id" .
    "&status=acknowledged,resolved&sort_by=incident_number:desc'";
print "$cmd\n" if($opts{debug});
$j = scalar(`$cmd`);
my($i) = from_json($j, {allow_nonref=>1});
my($last) = $opts{last_id};
$last ||= (`touch $opts{last_id_file};cat $opts{last_id_file}` + 0);

my($nagstat) = {};
$cmd = "cat $opts{nagios_status_file} | grep -A50 'servicestatus {'" .
    "| egrep 'servicestatus|host_name|service_description|current_problem_id|problem_has_been_acknowledged' " .
    "| cut -d= -f2";
print "$cmd\n" if($opts{debug});
my(@statcat) = `$cmd`;
while(@statcat){
  chomp(my(undef, $h, $s, $pi, $a) = (shift(@statcat), shift(@statcat), shift(@statcat), shift(@statcat), shift(@statcat)));
  #next if($a != 0);
  next if($pi == 0);
  $nagstat->{$h}{$s} = $pi;
  $nagstat->{$h}{'ack'} = $a;
}
print Dumper $nagstat if($opts{debug});

my $previous_ack;
if (-e '/tmp/pd_acked') {
	print "Found previous file\n";
	$previous_ack = retrieve '/tmp/pd_acked';
} else {
	print "Creating new file\n";
	$previous_ack = {};
}

my $new_ack = {};
for(reverse(@{$i->{incidents}})){
  my($in) = $_->{incident_number};
  my($iid) = $_->{id};
  if($in > $last){
    {
      print "$in\n" if($opts{debug});
      $cmd = "curl -s -H 'Authorization: Token token=$opts{pagerduty_token}' ".
          "'https://$opts{pagerduty_subdomain}.pagerduty.com/api/v1/incidents/$iid/log_entries'";
      print "$cmd\n" if($opts{debug});
      $j = scalar(`$cmd`);
      my($ls) = from_json($j, {allow_nonref=>1});
      print Dumper $ls if($opts{debug});
      # skip if this is not a nagios alert
      last unless($ls->{log_entries}[$#{$ls->{log_entries}}]{channel}{type} eq 'nagios');
      # filter out non-ack/resolve
      my($lf) = [grep {$_->{type} =~ /^(resolve|acknowledge)/} @{$ls->{log_entries}}];
      # skip if nagios ack/resolution came from nagios
      last if($lf->[0]{channel}{type} eq 'nagios');
      # skip if resolution was a timeout
      last if($lf->[0]{channel}{type} eq 'timeout');
      my($u) = $lf->[0]{agent}{email} =~ /^([^\@]*)\@/;
      my($c) = $lf->[0]{channel}{type};
      my($lt) = $lf->[0]{type};
      my($li) = $ls->{log_entries}[$#{$ls->{log_entries}}]{id};
      $cmd = "curl -s -H 'Authorization: Token token=$opts{pagerduty_token}' " .
          "'https://$opts{pagerduty_subdomain}.pagerduty.com/api/v1/log_entries/$li?include%5B%5D=channel'";
      print "$cmd\n" if($opts{debug});
      $j = scalar(`$cmd`);
      my($raw) = from_json($j, {allow_nonref=>1});
      print Dumper $raw->{log_entry}{channel}{details} if($opts{debug});
      my($h) = $raw->{log_entry}{channel}{details}{HOSTDISPLAYNAME};
      my($s) = $raw->{log_entry}{channel}{details}{SERVICEDISPLAYNAME};
      my($pi) = $raw->{log_entry}{channel}{details}{SERVICEPROBLEMID};
      # skip if there's no problem id in nagios (meaning service is
      # already recovered), or if the problem id is more recent than
      # the one in the raw pagerduty entry.
      if($nagstat->{$h}{$s} && ($nagstat->{$h}{$s} <= $pi && $nagstat->{$h}{$a} != 1)){
        my($t) = time;
        #ACKNOWLEDGE_SVC_PROBLEM;<host_name>;<service_description>;<sticky>;<notify>;<persistent>;<author>;<comment>
        $cmd = "echo '[$t] ACKNOWLEDGE_SVC_PROBLEM;$h;$s;1;0;1;$u;pd event $in $lt by $u via $c' >$opts{nagios_command_pipe}";
        print "$cmd\n" if($opts{debug});
        `$cmd`;
	# save ACKed incident so we can resolve it later (if needed)
	$new_ack->{$iid} = $in;
      }
    }
    `echo $in >$opts{last_id_file}` unless($opts{last_id});
  }
}

print Dumper $previous_ack;
# now loop over the previous ACKed incidents and see if they have been resolved
foreach my $incident ( keys %$previous_ack ) {
	# make API call to see if the incident has been resolved
	$cmd =  "curl -s -H 'Authorization: Token token=$opts{pagerduty_token}' ".
          "'https://$opts{pagerduty_subdomain}.pagerduty.com/api/v1/incidents/$incident/log_entries'";
	print "$cmd\n" if ($opts{debug});
	$j = scalar(`$cmd`);
	my ($ls) = from_json($j, {allow_nonref=>1});
	print Dumper $ls if ($opts{debug});

	# skip if this is not a nagios alert
	last unless($ls->{log_entries}[$#{$ls->{log_entries}}]{channel}{type} eq 'nagios');
	# filter out non-ack/resolve
        my($lf) = [grep {$_->{type} =~ /^(resolve)/} @{$ls->{log_entries}}];
	print Dumper $lf if ($opts{debug});
        # skip if nagios ack/resolution came from nagios (user through nagios gui resolved, so
	# no need to send command to nagios)
	last if($lf->[0]{channel}{type} eq 'nagios');
	# skip if resolution was a timeout
	last if($lf->[0]{channel}{type} eq 'timeout');
	my($li) = $ls->{log_entries}[$#{$ls->{log_entries}}]{id};
      	$cmd = "curl -s -H 'Authorization: Token token=$opts{pagerduty_token}' " .
          "'https://$opts{pagerduty_subdomain}.pagerduty.com/api/v1/log_entries/$li?include%5B%5D=channel'";
      	print "$cmd\n" if($opts{debug});
      	$j = scalar(`$cmd`);
      	my($raw) = from_json($j, {allow_nonref=>1});
	print Dumper $raw if ($opts{debug});
	my($h) = $raw->{log_entry}{channel}{details}{HOSTDISPLAYNAME};
	my($s) = $raw->{log_entry}{channel}{details}{SERVICEDISPLAYNAME};
	my($pi) = $raw->{log_entry}{channel}{details}{SERVICEPROBLEMID};

	print "Nagstat : " . $nagstat->{$h}{$s} . "\n";
	print "Pager Duty : " . $pi . "\n";
	print "Ack number : " . $nagstat->{$h}{'ack'} . "\n";
	if ($nagstat->{$h}{$s} && ($nagstat->{$h}{$s} <= $pi && $nagstat->{$h}{'ack'} == 1)) {
		my($t) = time;
		#REMOVE_SVC_ACKNOWLEDGEMENT;<host_name>;<service_description>
		$cmd = "echo '[$t] REMOVE_SVC_ACKNOWLEDGEMENT;$h;$s' >$opts{nagios_command_pipe}";
		print "$cmd\n" if ($opts{debug});
		`$cmd`;
		#SCHEDULE_FORCED_SVC_CHECK;<host_name>;<service_description>;<check_time>
		$cmd = "echo '[$t] SCHEDULE_FORCED_SVC_CHECK;$h;$s;$t' >$opts{nagios_command_pipe}";
		`$cmd`;
		# delete this incident from stored hash
		delete $previous_ack->{$incident};
	}

}
print Dumper $previous_ack;
# combine the previous_ack and new_ack and store 
my %merged = (%$new_ack, %$previous_ack);
print Dumper \%merged;
# update our data store
store \%merged, '/tmp/pd_acked';
